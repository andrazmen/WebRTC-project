<!DOCTYPE html>
<html>
  <head>
    <h1>WebRTC</h1>
  </head>
  <body>

    <div id="messages"></div>
    <div id="errorMsg"></div>

    <video id="localVideo" autoplay playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>

    <button id="showVideo">Open camera</button>
    <button id="makeCall">Make call</button>
    <button id="endCall" style="display: none">End call</button>

    <script>
      const socket = new WebSocket("ws://localhost:443/");

      socket.addEventListener("open", () => {
        console.log("I am connected!");
      });

      const constraints = (window.constraints = {
        audio: false,
        video: true,
      });

      async function openCamera(e) {
        console.log('Im in the open camera function');
        try {
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          const video = document.querySelector("#localVideo");
          const videoTracks = stream.getVideoTracks();
          console.log("Got stream with constraints:", constraints);
          console.log(`Using video device: ${videoTracks[0].label}`);
          window.stream = stream; // make variable available to browser console
          video.srcObject = stream;
          e.target.disabled = true;

        } catch (e) {
          console.log('e');
          handleError(e);
        }
      }

      function handleError(error) {
        if (error.name === "OverconstrainedError") {
          const v = constraints.video;
          errorMsg(
            `The resolution ${v.width.exact}x${v.height.exact} px is not supported by your device.`
          );
        } else if (error.name === "NotAllowedError") {
          errorMsg(
            "Permissions have not been granted to use your camera and " +
              "microphone, you need to allow the page access to your devices in " +
              "order for the demo to work."
          );
        }
        errorMsg(`getUserMedia error: ${error.name}`, error);
      }

      function errorMsg(msg, error) {
        const errorElement = document.querySelector("#errorMsg");
        errorElement.innerHTML += `<p>${msg}</p>`;
        if (typeof error !== "undefined") {
          console.error(error);
        }
      }
      
      async function makeCall(stream) {
        // Create an RTCPeerConnection
        const localPeerConnection = new RTCPeerConnection();

        // Add the local stream to the connection
        stream
          .getTracks()
          .forEach((localTrack) =>
            localPeerConnection.addTrack(localTrack, stream)
          );
        console.log("Stream on client 1 side added to the connection: ", stream);

        // Create offer
        const localOffer = await localPeerConnection.createOffer();

        // Set that offer as local description
        await localPeerConnection.setLocalDescription(localOffer);
        console.log("Local description set");

        // Send offer
        socket.send(JSON.stringify({ type: 'offer', sdp: localOffer.sdp }));
        console.log('This is localOffer: ', JSON.stringify({ type: 'offer', sdp: localOffer.sdp }));
        console.log("Local offer send");

        // Listening for offers
        socket.addEventListener("message", async (message) => {
          
          const data = JSON.parse(message.data);
          console.log('Answer data: ', data);

          if (data.type == 'answer') {
            // Set this offer as remote description
            await localPeerConnection.setRemoteDescription(
              new RTCSessionDescription(data)
            );
            console.log("Remote description set");
          }
        });

        // Listen for local ICE candidates on the local RTCPeerConnection
        localPeerConnection.addEventListener("icecandidate", (event) => {
          if (event.candidate) {
            console.log(event.candidate);

            socket.send(JSON.stringify(event.candidate));
            console.log("Ice candidates send");
          }
        });

        // Listen for connectionstatechange on the local RTCPeerConnection
        localPeerConnection.addEventListener("connectionstatechange", (event) => {
          if (localPeerConnection.connectionState === "connected") {
            console.log("Peers connected from client 1 side!");
            const callButton = document.querySelector("#makeCall");
            callButton.style.display = "none";
            const endButton = document.querySelector("#endCall");
            endButton.style.display = "block";
          }
        });

        // Adding remote video
        const remoteVideo = document.querySelector('#remoteVideo');

        localPeerConnection.addEventListener("track", async (event) => {
          const [remoteStream] = event.streams;
          remoteVideo.srcObject = remoteStream;
          console.log('Remote video added: ', remoteStream);
        });

        // Disconnection check
        localPeerConnection.addEventListener("connectionstatechange", (event) => {
          if (localPeerConnection.connectionState === "disconnected") {
            console.log("Peer connection closed!");
            localPeerConnection.close();
            const makeCallButton = document.querySelector("#makeCall");
            makeCallButton.style.display = "block";
            const endCallButton = document.querySelector("#endCall");
            endCallButton.style.display = "none";
            //const remoteVideoElement = document.querySelector("#remoteVideo");
            //remoteVideoElement.style.display = "none";
            //restoreRTC();
          }
        });

        // End call
        document
          .querySelector("#endCall")
          .addEventListener("click", () => {
            localPeerConnection.close();
            console.log("Peer connection closed!");
            const makeCallButton = document.querySelector("#makeCall");
            makeCallButton.style.display = "block";
            const endCallButton = document.querySelector("#endCall");
            endCallButton.style.display = "none";
            //const remoteVideoElement = document.querySelector("#remoteVideo");
            //remoteVideoElement.style.display = "none";
            //restoreRTC();
          });
      }

      // CLIENT 2
      // Create an RTCPeerConnection
      const peerConnection = new RTCPeerConnection();
      console.log("RTCPeerConnection created");


      // Listening for offers
      socket.addEventListener("message", async (message) => {
        const data = JSON.parse(message.data)
        console.log('This is a message: ', data);

        if (data.type == 'offer') {
          // Add the stream to the connection
          stream
            .getTracks()
            .forEach((localTrack) =>
              peerConnection.addTrack(localTrack, stream)
            );
          console.log("Stream on client 2 side added to the connection: ", stream);

          // Set remote descripton
          await peerConnection.setRemoteDescription(
            new RTCSessionDescription(data)
          );
          console.log("Remote description set");
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          console.log("Local description set");
          console.log('This is answer:', JSON.stringify({ type: 'answer', sdp: answer.sdp }));
          socket.send(JSON.stringify({ type: 'answer', sdp: answer.sdp }));
        }
      });

      socket.addEventListener("message", async (message) => {

        try {
          const data = JSON.parse(message.data);
          console.log(data.candidate);
          if (data.candidate) {
            try {
              await peerConnection.addIceCandidate(data);
            } catch (e) {
              console.error("Error adding received ice candidate", e);
            }
          }
        } catch (error) {
          console.error('Error parsing JSON:', error);
        }
      });

      // Listen for connectionstatechange
      peerConnection.addEventListener("connectionstatechange", (event) => {
        if (peerConnection.connectionState === "connected") {
          console.log("Peers connected from client 2 side!");
          const callButton = document.querySelector("#makeCall");
          callButton.style.display = "none";
          const endButton = document.querySelector("#endCall");
          endButton.style.display = "block";
        }
      });

      const remoteVideo = document.querySelector('#remoteVideo');

      peerConnection.addEventListener('track', async (event) => {
        const [remoteStream] = event.streams;
        remoteVideo.srcObject = remoteStream;
        console.log('Remote video added: ', remoteStream);
      });

      // Disconnection check
      peerConnection.addEventListener("connectionstatechange", (event) => {
          if (peerConnection.connectionState === "disconnected") {
            console.log("Peer connection closed!");
            peerConnection.close();
            const makeCallButton = document.querySelector("#makeCall");
            makeCallButton.style.display = "block";
            const endCallButton = document.querySelector("#endCall");
            endCallButton.style.display = "none";
            //const remoteVideoElement = document.querySelector("#remoteVideo");
            //remoteVideoElement.style.display = "none";
            restoreRTC();
          }
      });
      /*
      async function restoreRTC(){
        const peerConnection = new RTCPeerConnection();
        console.log("RTCPeerConnection created. Ready for new one.");
        const remoteVideoElement = document.querySelector("#remoteVideo");
        remoteVideoElement.style.display = "block";
      }
        */    
      document
        .querySelector("#showVideo")
        .addEventListener("click", (e) => {
          const stream = openCamera(e);
        });

      document
        .querySelector("#makeCall")
        .addEventListener("click", () => makeCall(stream));

      document
        .querySelector("#endCall")
        .addEventListener("click", () => {
          peerConnection.close();
          console.log("Peer connection closed!");
          const makeCallButton = document.querySelector("#makeCall");
          makeCallButton.style.display = "block";
          const endCallButton = document.querySelector("#endCall");
          endCallButton.style.display = "none";
          //const remoteVideoElement = document.querySelector("#remoteVideo");
          //remoteVideoElement.style.display = "none";
          //restoreRTC();
        });

    </script>
  </body>
</html>
